#!/usr/bin/env python3
# Questions
# MC looks like it has fluctuating error

import numpy as np, matplotlib.pyplot as plt, random, math
from toolz import *            # is this ok???

def f(x):
    return (x**3)

def f2(x):
    return math.sin(x)

# integrate function 2, MC function

def integrate_mc(f,a,b,sometuple, numsample = 1000):

    c,d = sometuple
    area = abs(b - a) * abs(c - d)

    outx = []
    outy = []
    posx = []
    posy = []
    negx = []
    negy = []
    for i in range(0, numsample):
        x1 = random.uniform(a, b)
        y1 = random.uniform(c, d)
        ys = f(x1)

        # if ys is positive
        if ys > 0:
            if y1 > 0 and y1 <= ys:
                posx.append(x1)
                posy.append(y1)

            else:
                outx.append(x1)
                outy.append(y1)

        # if ys is negative
        elif ys < 0 or ys == 0:
            if y1 < 0 and y1 >= ys:
                negx.append(x1)
                negy.append(y1)

            else:
                outx.append(x1)
                outy.append(y1)

    # if you want a hot mess, uncomment these lines:
    # plt.plot(posx, posy, 'go')
    # plt.plot(outx, outy, 'ro')
    # plt.plot(negx, negy, 'bo')
    # plt.grid(True)
    # plt.show()

    result = area * ((len(posx)/numsample) - (len(negx)/numsample))

    return result

# integrate function 1, Riemann Sums

def integrate(f,a,b,numstep = 100):  # what should the default numstep be??? Setting it to 100

    if type(a) != int and type(a) != float:
        print('Use a number for a, not whatever you did!')
        raise ValueError

    if type(b) != int and type(b) != float:
        print('Use a number for b, not whatever you did!')
        raise ValueError

    if type(numstep) != int and type(numstep) != float:
        print('Use a number for numstep, not whatever you did!')
        raise ValueError

    sumint = 0                       # placeholder for sum
    stepsize = (b-a)/numstep      # calculate step size
    area = []                     # empty array for area of rectangles
    y = []                        # empty array for y values
    x = np.linspace(a,b,numstep)  # x values
    for i in x:
        y.append(f(i))            # makes list of y values corresponding to x values
        area.append(stepsize * f(i))

    for i in area:
        sumint = sumint + i              # sum all the areas

    return sumint


# function for approx. pi

def approximate_pi(numsample = 1000):  # n is the number of samples used

    area = 4
    overx = []
    overy = []
    underx = []
    undery = []
    for i in range(0, numsample):
        x1 = random.uniform(-1, 1)
        y1 = random.uniform(-1, 1)
        length = math.sqrt(x1**2 + y1**2)
        if length >= 1:
            overx.append(x1)
            overy.append(y1)

        else:
            underx.append(x1)
            undery.append(y1)

    approx = area * len(underx) / numsample
    # plot
    plt.plot(overx, overy, 'ro')
    plt.plot(underx, undery, 'bo')
    plt.title('MC Unit Circle')
    plt.grid(True)
    # plt.show()

    return approx


if __name__ == '__main__':

    solution = 156.25
# riemann sum
    sum1 = integrate(f2, 0, math.pi)
    print('Riemann sum integration result:', sum1)

# MC, between 0 and 5 0.25x^4 goes to just under 160. Use -10, 170 as the bounding box

    sum2 = integrate_mc(f, 0, 5, (-10,170),5000)

    print('Monte Carlo integration result:', sum2)

    sum3 = integrate_mc(f2, 0, 3 * math.pi, (-1.5, 1.5),5000)

    print('Monte Carlo integration result:', sum3)

# # plot results and errors:
# MC Error
    numpts = 1000    # for keeping the number of points consistent
    error1 = []
    error2 = []
    for i in range(100,numpts):
        mcsum = integrate_mc(f,0,5,(0,160),i)
        error1.append(abs(mcsum - solution))

# Riemann sum error
    ind = []
    for i in range(100, numpts):
        ind.append(i)
        rsum = integrate(f,0,5,i)
        error2.append(abs(rsum - solution))


    # plot
    plt.plot(ind, error1, 'ro', label = "MC Error")
    plt.plot(ind,error2,'bo', label = "Riemann Sum Error")
    plt.title('Riemann Sum and MC Error vs # of Samples')
    plt.grid(True)
    plt.xlabel('Number of Samples')
    plt.ylabel('Error')
    plt.legend()
    plt.show()

# # plot function curve
#
#     a = np.linspace(0, 5, 100)
#     y = []
#     for i in a:
#         y.append(f(i))
#
#     plt.plot(a, y)  # plot x^4 / 4
#     plt.grid(True)
#     plt.show()
#
# # estimate pi
#
#     est = approximate_pi(100000)
#     print('Monte Carlo estimate of pi:', est)




