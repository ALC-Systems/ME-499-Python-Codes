#!/usr/bin/env python3
import math, numpy, random
from scipy import optimize


# functions for testing
def f(x):
    return (x**3)

def f(x):
    return -1 * (x**3)

def f2(x):
    return math.sin(x)

def f2neg(x):
    return -1 * math.sin(x)

def f3(x,y):   # this is a 3d function
    z = x**2 + y**2
    return z

# stepping up
def optimize_step(f,bounds,n):
    y = []
    lower, upper = bounds
    x = numpy.linspace(lower, upper, n)
    maxval = f(x[0])          # first known max. since it's the only one
    xval = x[0]
    for i in x:
        y.append(f(i))
        if f(i) > maxval:     # if current value greater than known max thus far
            maxval = f(i)     # ...overwrite the known maxval.
            xval = i
    return maxval,xval   # may need to get rid of the "maxval".


# random samples doing the same thing
def optimize_random(f, bounds, n):
    y = []
    lower, upper = bounds
    xval = random.uniform(lower, upper)   # first known x
    maxval = f(xval)        # first known max, since it's the only one...
    for i in range(0,n):
        x = random.uniform(lower, upper)
        y.append(f(x))
        if f(i) > maxval:  # if current value greater than known max thus far
            maxval = f(i)  # ...overwrite the known maxval.
            xval = i
    return maxval, xval

# multi dimensional ( really just 3d...maybe 4)
def optimize_md(f,bounds,n=1000):   # default takes 1000 steps
    lowerx,upperx,lowery, uppery = bounds
    x = numpy.linspace(lowerx, upperx, n)
    y = numpy.linspace(lowery, uppery, n)
    z = []
    maxval = f(x[0],y[0])    # initial
    xval = x[0]              # initial x value
    yval = y[0]
    for i in x:
        for j in y:
            z.append(f(i,j))
            if f(i) > maxval:  # if current value greater than known max thus far
                maxval = f(i)  # ...overwrite the known maxval.
                xval = i
                yval = j

    tup = (xval,yval,maxval)

    return tup


if __name__ == '__main__':

    solution = optimize_step(f2,(0,4),1000)
    print(solution)

    solution2 = optimize_random(f2,(0,4),1000)
    print(solution2)

    optsol = optimize.fmin(f2neg,1)




